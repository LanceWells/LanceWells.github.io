{"version":3,"sources":["serviceWorker.ts","BodyMap.tsx","BodySelector.tsx","PartSelector.tsx","PartAccordion.tsx","CharacterCanvas.tsx","CharacterCreator.tsx","index.tsx","LandingSpace.tsx"],"names":["Boolean","window","location","hostname","match","bodyMaps","Array","push","name","description","imageSource","layers","avgMasculineLayers","avgFeminineLayers","avgMasculineReptilianLayers","avgFeminineReptilianLayers","BodySelector","props","Button","className","variant","style","borderColor","boxShadow","width","onClick","bodyMap","src","Carousel","Caption","PartSelector","layerIndex","rounded","PartAccordion","layer","images","map","this","Card","background","text","Accordion","Toggle","as","Header","eventKey","toString","cursor","key","Collapse","Body","renderPartsButtons","Tab","title","Tabs","defaultActiveKey","id","renderPartTabs","React","Component","CharacterCanvas","canvasHeight","canvasWidth","outlineColors","handleOutlineColorChange","color","setState","outlineColor","hex","state","canvas","refs","borderCanvas","display","getContext","imageSmoothingEnabled","prevProps","imagesWidth","imagesHeight","loadedImages","promiseArray","imagesToRender","image","index","imgSrc","height","Promise","resolve","partImg","Image","onload","renderImagesFn","all","then","charCtx","charCanvas","clearRect","forEach","img","drawImage","charImgSrc","toDataURL","borderImg","borderCtx","borderStyle","dArr","i","length","globalCompositeOperation","fillStyle","fillRect","drawImageBorder","ref","backgroundImage","Container","fluid","Row","onChangeComplete","colors","onClickDownload","document","getElementById","CharacterCreator","canvasImages","partLayers","carouselIndex","carouselDirection","downloadUrl","link","createElement","download","href","click","newCanvasImages","newImagesToRender","includes","Item","body","handleBodySelection","direction","canvasImagesToRender","currentBodyMap","Col","lg","interval","indicators","onSelect","handleCarouselSelect","bind","renderBodySelection","downloadImage","layerName","handlePartSelection","ReactDOM","render","to","path","component","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.31926f8b.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import avgFeminineLayers from './json/avg_Feminine.json';\r\nimport avgMasculineLayers from './json/avg_Masculine.json';\r\nimport avgFeminineReptilianLayers from './json/avg_Feminine_Reptilian.json';\r\nimport avgMasculineReptilianLayers from './json/avg_Masculine_Reptilian.json';\r\n\r\n/**\r\n * @description\r\n * The contents of each image \"layer\" that can be overlayed on top of the character image. This contains info\r\n * about what the layer is called (e.g. 'clothing', or 'hats'), what the z-layer info is for the layer, and a\r\n * list of possible image sources that are contained in the image layer.\r\n * @param key The name of the layer.\r\n * @param layerIndex The z-index of the layer. The higher the number, the more 'in front' that the layer is.\r\n * @param images A list of possible image sources that are drawn in this layer. Only one of these can be drawn\r\n * from this list at a time (this is intentional).\r\n */\r\nexport type ImageLayer = {\r\n    key: string;\r\n    layerIndex: number;\r\n    images: ImageDescriptor[];\r\n}\r\n\r\nexport type ImageDescriptor = {\r\n    imageSource: string;\r\n    tags: string[];\r\n}\r\n\r\n/**\r\n * @description\r\n * A mapping from the body that will be displayed to the list of layers associated with that body.\r\n */\r\nexport type BodyMap = {\r\n    name: string;\r\n    description: string;\r\n    imageSource: string;\r\n    layers: ImageLayer[];\r\n}\r\n\r\n/**\r\n * @remarks The layer index for every layer starts at 1. This is because '0' is reserved for the base\r\n * body. Setting this to '0' on a layer will remove the base body.\r\n */\r\nexport var bodyMaps: BodyMap[] = new Array(0);\r\nbodyMaps.push({\r\n    name: 'Average-Sized, Masculine',\r\n    description: \"Masculine body type! Of average size; good for humans, elves, orcs, and tieflings.\",\r\n    imageSource: \"./images/Examples/Avg_Male.png\",\r\n    layers: avgMasculineLayers\r\n}, {\r\n    name: 'Average-Sized, Feminine',\r\n    description: \"Feminine body type! Of average size; good for humans, elves, orcs, and tieflings.\",\r\n    imageSource: \"./images/Examples/Avg_Female.png\",\r\n    layers: avgFeminineLayers\r\n}, {\r\n    name: 'Dragonborn, Masculine',\r\n    description: \"Dragonborn! Cold-blooded and rainbow-colored! These are masculine-bodied dragonborn.\",\r\n    imageSource: \"./images/Examples/Reptilian_Male.png\",\r\n    layers: avgMasculineReptilianLayers\r\n}, {\r\n    name: 'Dragonborn, Feminine',\r\n    description: \"Dragonborn! Cold-blooded and rainbow-colored! These are feminine-bodied dragonborn.\",\r\n    imageSource: \"./images/Examples/Reptilian_Female.png\",\r\n    layers: avgFeminineReptilianLayers\r\n}\r\n);\r\n","import React from 'react';\r\nimport Button from 'react-bootstrap/Button';\r\nimport { BodyMap } from './BodyMap';\r\nimport { Carousel } from 'react-bootstrap';\r\n\r\ninterface IBodySelector {\r\n    onClick: Function;\r\n    bodyMap: BodyMap;\r\n}\r\n\r\nexport function BodySelector(props: IBodySelector) {\r\n    return (\r\n        <Button\r\n            className='bodySelector'\r\n            variant='dark'\r\n            style={{\r\n                borderColor: 'rgba(255, 255, 255, 0.05)',\r\n                boxShadow: '0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19)',\r\n                width: '100%'\r\n            }}\r\n            onClick={() => props.onClick(props.bodyMap)}>\r\n            <img src={props.bodyMap.imageSource} />\r\n            <Carousel.Caption>\r\n                <h3 className='body-option-title'>{props.bodyMap.name}</h3>\r\n                <p className='body-option-caption'>{props.bodyMap.description}</p>\r\n            </Carousel.Caption>\r\n        </Button>\r\n    )\r\n}\r\n","import React from 'react';\r\nimport Image from 'react-bootstrap/Image';\r\nimport Button from 'react-bootstrap/Button';\r\n\r\ninterface IPartSelector {\r\n    onClick: Function;\r\n    layerIndex: number;\r\n    imageSource: string;\r\n}\r\n\r\nexport default function PartSelector(props: IPartSelector) {\r\n    return (\r\n        <Button\r\n            className='part-selector-button'\r\n            variant='dark'\r\n            style={{\r\n                borderColor: 'rgba(255, 255, 255, 0.05)',\r\n                boxShadow: '0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19)'\r\n            }}\r\n            onClick={() => props.onClick(props.layerIndex, props.imageSource)}>\r\n            <Image\r\n                className='partSelector'\r\n                src={props.imageSource}\r\n                rounded />\r\n        </Button>\r\n    )\r\n}","import React from 'react';\r\nimport { ImageLayer } from './BodyMap';\r\nimport PartSelector from './PartSelector';\r\nimport Card from 'react-bootstrap/Card';\r\nimport Accordion from 'react-bootstrap/Accordion';\r\nimport Tab from 'react-bootstrap/Tab';\r\nimport Tabs from 'react-bootstrap/Tabs'\r\n\r\ninterface IPartAccordionProps {\r\n    layers: ImageLayer[];\r\n    onClick: Function;\r\n}\r\n\r\nexport class PartAccordion extends React.Component<IPartAccordionProps> {\r\n    renderPartsButtons(layer: ImageLayer) {\r\n        return layer.images.map((src) => {\r\n            return (\r\n                <PartSelector\r\n                    onClick={this.props.onClick}\r\n                    layerIndex={layer.layerIndex}\r\n                    imageSource={src.imageSource}\r\n                />\r\n            );\r\n        });\r\n    }\r\n\r\n    renderPartCards() {\r\n        return this.props.layers.map((layer) => {\r\n            return (\r\n                <Card style={{ background: 'rgba(255, 255, 255, 0.07)' }} text=\"white\">\r\n                    <Accordion.Toggle as={Card.Header} eventKey={layer.layerIndex.toString()}\r\n                        style={{ cursor: \"pointer\" }}>\r\n                        {layer.key}\r\n                    </Accordion.Toggle>\r\n                    <Accordion.Collapse eventKey={layer.layerIndex.toString()}>\r\n                        <Card.Body>\r\n                            {this.renderPartsButtons(layer)}\r\n                        </Card.Body>\r\n                    </Accordion.Collapse>\r\n                </Card>\r\n            );\r\n        });\r\n    }\r\n\r\n    renderPartTabs() {\r\n        return this.props.layers.map((layer) => {\r\n            return (\r\n                <Tab eventKey={layer.layerIndex.toString()} title={layer.key}>\r\n                    <div className='part-button-tab'>\r\n                        {this.renderPartsButtons(layer)}\r\n                    </div>\r\n                </Tab>\r\n            );\r\n        });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <Tabs defaultActiveKey=\"Body\" id=\"part-accordion-tabs\">\r\n                    {this.renderPartTabs()}\r\n                </Tabs>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// https://blog.cloudboost.io/using-html5-canvas-with-react-ff7d93f5dc76\r\nimport React from 'react';\r\nimport Button from 'react-bootstrap/Button';\r\nimport { Color, ColorResult, CirclePicker } from 'react-color';\r\nimport { Container } from 'react-bootstrap';\r\nimport { Row } from 'react-bootstrap';\r\n\r\n/**\r\n * @description An interface used to describe the elements provided to this class at creation.\r\n */\r\ninterface ICanvasProps {\r\n    /**\r\n     * @description A list of images to render. This may be updated at-will by the parent, and this element\r\n     * will render those new images.\r\n     */\r\n    imagesToRender: Array<string>;\r\n\r\n    /**\r\n     * @description A callback to this class' \"DOWNLOAD\" button. Owned by the parent.\r\n     */\r\n    onClickDownload: Function;\r\n}\r\n\r\n/**\r\n * @description An interface used to describe the elements maintained by this class' internal state.\r\n */\r\ninterface ICanvasState {\r\n    /**\r\n     * @description The color of the outline border for the character's profile. This will be included when\r\n     * saving the image.\r\n     */\r\n    outlineColor: Color;\r\n}\r\n\r\n/**\r\n * @description A class used to display a character's profile on a canvas element. Also provides a border,\r\n * tools to change the color of the border, and a means to download the image itself.\r\n */\r\nexport class CharacterCanvas extends React.Component<ICanvasProps, ICanvasState> {\r\n    /**\r\n     * @description The height of the canvas' used by this object.\r\n     */\r\n    canvasHeight: number = 256;\r\n\r\n    /**\r\n     * @description The width of the canvas' used by this object.\r\n     */\r\n    canvasWidth: number = 256;\r\n\r\n    /**\r\n     * @description A list of all possible outline color that may be used by the canvas.\r\n     */\r\n    outlineColors: string[] = [\"#131313\", \"#ffffff\", \"#571c27\" ];\r\n\r\n    /**\r\n     * @description The constructor for this object.\r\n     * @param props A list of properties provided by the parent object.\r\n     */\r\n    constructor(props: Readonly<ICanvasProps>) {\r\n        super(props);\r\n        this.state = {\r\n            outlineColor: \"#ffffff\"\r\n        };\r\n    }\r\n\r\n    /**\r\n     * A handler for when this component has been fully loaded. Establishes some basic settings about how to\r\n     * handle the image.\r\n     */\r\n    componentDidMount() {\r\n        const canvas = this.refs.canvas as HTMLCanvasElement;\r\n        const borderCanvas = this.refs.borderCanvas as HTMLCanvasElement;\r\n\r\n        canvas.style.display = \"none\";\r\n        \r\n        const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n        ctx.imageSmoothingEnabled = false;\r\n\r\n        const borderCtx = borderCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n        borderCtx.imageSmoothingEnabled = false;\r\n    }\r\n\r\n    /**\r\n     * @description A handler for a change on an outline color.\r\n     */\r\n    handleOutlineColorChange = (color: ColorResult) => {\r\n        this.setState({\r\n            outlineColor: color.hex\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @description A handler for when the component itself updates; either the props or the state of this\r\n     * object. Updates the character display.\r\n     * @param prevProps \r\n     */\r\n    componentDidUpdate(prevProps: ICanvasProps)\r\n    {\r\n        const imagesWidth = this.canvasWidth;\r\n        const imagesHeight = this.canvasHeight;\r\n\r\n        // https://stackoverflow.com/questions/34534549/how-do-you-deal-with-html5s-canvas-image-load-asynchrony\r\n        var loadedImages: Array<HTMLImageElement> = new Array<HTMLImageElement>();\r\n\r\n        /**\r\n         * Provides a function to be used when loading each of the images that will be drawn on the character.\r\n         * @param loadedImages A list of loaded images to maintain outside of this function. This needs to be\r\n         * accessible from where the promise list is being run.\r\n         * @param index The index of the array @see loadedImages that the result of the promise will end up\r\n         * in.\r\n         * @param imgSrc The string/html source for the image to be rendered.\r\n         * @param width The width of the image to be rendered.\r\n         * @param height The height of the image to be rendered.\r\n         */\r\n        var renderImagesFn = function(\r\n                loadedImages: Array<HTMLImageElement>,\r\n                index: number,\r\n                imgSrc: string,\r\n                width: number,\r\n                height: number) {\r\n            return new Promise<void>(resolve => {\r\n                var partImg = new Image(width, height);\r\n                \r\n                partImg.onload = function() {\r\n                    loadedImages[index] = partImg;\r\n                    resolve();\r\n                };\r\n\r\n                partImg.src = imgSrc;\r\n            })\r\n        };\r\n\r\n        // Take the list of images that we should render, and ensure that each and every one of them is A:\r\n        // rendered, and B: exists in a separate loadedImages array for us to draw next.\r\n        var promiseArray = this.props.imagesToRender.map(\r\n            (image, index) => renderImagesFn(loadedImages, index, image, this.canvasWidth, this.canvasHeight));\r\n\r\n        // Ensure that all of the promises have been met, then call the giant handleImagesLoaded() function to\r\n        // draw the images and their border.\r\n        Promise.all(promiseArray).then(handleImagesLoaded);\r\n\r\n        const borderColor= this.state.outlineColor as Color;\r\n        const charCanvas = this.refs.canvas as HTMLCanvasElement;\r\n        const borderCanvas = this.refs.borderCanvas as HTMLCanvasElement;\r\n\r\n        /**\r\n         * @description A function used to handle the final images loaded event. Draws each image in-order,\r\n         * and renders a border around the final image.\r\n         */\r\n        function handleImagesLoaded()\r\n        {\r\n            const charCtx = charCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n            charCtx.clearRect(0, 0, charCanvas.width, charCanvas.height);\r\n\r\n            // Draw the images in-order.\r\n            loadedImages.forEach(img => {\r\n                charCtx.drawImage(img, 0, 0, img.width, img.height);\r\n            });\r\n\r\n            /*\r\n             * Get a copy of the first canvas element. The original canvas element is hidden, but we use it\r\n             * to create a finalized version of the character image so that we have something to draw a border\r\n             * around. Otherwise, we're drawing a border around a bunch of tiny elements, which causes a\r\n             * bunch of tiny, overlapping borders.\r\n             */\r\n            var charImgSrc = charCanvas.toDataURL() as string;\r\n            var borderImg = new Image(imagesWidth, imagesHeight);\r\n            borderImg.src = charImgSrc;\r\n            \r\n            /**\r\n             * Handles the border image's onload event. This causes the image in the final canvas element, the\r\n             * canvas that draws the image and its border, to be rendered.\r\n             */\r\n            borderImg.onload = () => {\r\n                const borderCtx = borderCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n                borderCtx.clearRect(0, 0, borderCanvas.width, borderCanvas.height);\r\n                \r\n                drawImageBorder(borderCanvas, borderImg, borderColor.toString());\r\n\r\n                /**\r\n                 * @description Draws a border around an image with the specified elements, using the\r\n                 * specified image.\r\n                 * @param borderCanvas The canvas that will contain the final border and the final image. This\r\n                 * gets the border drawn to it.\r\n                 * @param img The image to use as a framework for the border.\r\n                 * @param borderStyle The styling to apply to the border image, when drawn.\r\n                 * @remarks https://stackoverflow.com/questions/28207232/draw-border-around-nontransparent-part-of-image-on-canvas\r\n                 * Something to note about this algorith; it can only draw borders of a thickness equal to the\r\n                 * smallest outlying pixel. So, our resolution for pixels on this canvas is '4', which means\r\n                 * that the thickness must be 4, or else we end up with weird stamping artifacts.\r\n                 */\r\n                function drawImageBorder(\r\n                    borderCanvas: HTMLCanvasElement,\r\n                    img: HTMLImageElement,\r\n                    borderStyle: string\r\n                    ) {\r\n                    const borderCtx = borderCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n                    /*\r\n                     * An array of integers used to offset and effectively \"stamp\" the image repeatedly. This\r\n                     * entire algorithm just takes the original image, stamps it around the base image 9\r\n                     * times, and then uses the source-in global composite operation to paint what's been\r\n                     * drawn according to the style used.\r\n                     * \r\n                     * Note that the numbers stored here are effectively pairs of coordinates to offset the\r\n                     * image stamping by, scaled by the desired thickness of the border.\r\n                     * https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing\r\n                     */\r\n                    var dArr = [\r\n                        -1, -1,\r\n                         0, -1,\r\n                         1, -1,\r\n                        -1,  0,\r\n                         1,  0,\r\n                        -1,  1,\r\n                         0,  1,\r\n                         1,  1];\r\n\r\n                        // Thickness scale\r\n                        var s: number = 4;\r\n\r\n                        // Iterator.\r\n                        var i: number = 0;\r\n\r\n                    // draw images at offsets from the array scaled by s\r\n                    for (; i < dArr.length; i += 2)\r\n                    {\r\n                        borderCtx.drawImage(img, dArr[i] * s, dArr[i + 1] * s);\r\n                    }\r\n\r\n                    // Fill with color\r\n                    borderCtx.globalCompositeOperation = \"source-in\";\r\n                    borderCtx.fillStyle = borderStyle;\r\n                    borderCtx.fillRect(0, 0, borderCanvas.width, borderCanvas.height);\r\n                }\r\n\r\n                borderCtx.globalCompositeOperation = \"source-over\";\r\n                borderCtx.drawImage(borderImg, 0, 0, borderImg.width, borderImg.height);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description Renders this object.\r\n     */\r\n    render() {\r\n        var outlineColor: string = this.state.outlineColor.toString();\r\n\r\n        return (\r\n            <div>\r\n                <canvas id=\"characterCanvas\" ref=\"canvas\" width={this.canvasWidth} height={this.canvasHeight} />\r\n                <canvas style={{ backgroundImage: \"linear-gradient(#131313, #ffffff)\" }} id=\"borderCanvas\" ref=\"borderCanvas\" width={this.canvasWidth} height={this.canvasHeight} />\r\n                <Container fluid={true} className='d-flex justify-content-center'>\r\n                    <Row>\r\n                        <CirclePicker\r\n                            onChangeComplete={this.handleOutlineColorChange}\r\n                            color={outlineColor}\r\n                            colors={this.outlineColors}\r\n                        />\r\n                    </Row>\r\n                </Container>\r\n                <Button\r\n                    variant=\"primary\"\r\n                    className=\"downloadButton\"\r\n                    onClick={() => this.props.onClickDownload(document.getElementById('borderCanvas'))}>\r\n                    <h4>&gt;&gt; DOWNLOAD &lt;&lt;</h4>\r\n                </Button>\r\n            </div>\r\n        )\r\n    }\r\n}","import './css/CharacterCreator.css';\r\nimport { bodyMaps, BodyMap, ImageLayer } from './BodyMap';\r\n\r\nimport React from 'react';\r\n\r\nimport {BodySelector} from './BodySelector';\r\nimport {PartAccordion} from './PartAccordion';\r\nimport {CharacterCanvas} from './CharacterCanvas';\r\n\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport Container from 'react-bootstrap/Container';\r\nimport Row from 'react-bootstrap/Row';\r\nimport Col from 'react-bootstrap/Col';\r\nimport { Carousel } from 'react-bootstrap';\r\n\r\n/**\r\n * @description\r\n * The interface for props passed to this object. This class in particular takes no props; it is effectively\r\n * the app itself.\r\n */\r\ninterface ICharacterCreatorProps {\r\n};\r\n\r\n/**\r\n * @description\r\n * The interface for the internal state maintained by this object.\r\n * @param canvasImages The list of image sources, represented as strings, that will be rendered using the\r\n * Canvas class.\r\n * @param partLayers A list of image layers. This contains information about all of the possible layers that\r\n * can be drawn to the currently-selected body type. This contains information about what each layer is, how\r\n * that layer is drawn, and what the possible images are in that layer.\r\n */\r\ninterface ICharacterCreatorState {\r\n    canvasImages: Array<string>,\r\n    partLayers: ImageLayer[],\r\n    carouselIndex: any,\r\n    carouselDirection: \"prev\" | \"next\"\r\n};\r\n\r\n/**\r\n * The main entry point for this application. Provides all of the buttons and fun stuff needed to create a\r\n * character image on a canvas element.\r\n */\r\nclass CharacterCreator extends React.Component<ICharacterCreatorProps, ICharacterCreatorState> {\r\n    constructor(props: ICharacterCreatorProps) {\r\n        super(props);\r\n        this.state = {\r\n            // Just fill the canvas images with nothing. We'll re-define it when we add to it.\r\n            canvasImages: new Array<string>(),\r\n            partLayers: Array(0),\r\n            carouselIndex: 0,\r\n            carouselDirection: \"next\"\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description\r\n     * Used to download the main character image from the canvas. This is a callback that is passed down to\r\n     * the canvas element.\r\n     * @param canvas The canvas html element from the Canvas character creator class.\r\n     */\r\n    downloadImage(canvas: HTMLCanvasElement)\r\n    {\r\n        const downloadUrl = canvas.toDataURL('image/png');\r\n        const link = document.createElement('a');\r\n\r\n        link.download = 'characterImage.png';\r\n        link.href = downloadUrl;\r\n        link.click();\r\n    }\r\n\r\n    /**\r\n     * A handler for a part selector. Replaces the image at the specified index with a new image.\r\n     * @param layerIndex The index of the layer. This is the z-layer, effectively. The higher the number, the\r\n     * more layers that it draws over.\r\n     * @param imageSource The image source. This is what gets drawn.\r\n     */\r\n    handlePartSelection(layerIndex: number, imageSource: string) {\r\n        const newCanvasImages: Array<string> = this.state.canvasImages;\r\n\r\n        // Javascript doesn't have arrays of fixed length, so this is safe? Still getting used to this.\r\n        newCanvasImages[layerIndex] = imageSource;\r\n\r\n        this.setState({\r\n            canvasImages: newCanvasImages\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Handles the prop-pass from the body-type selector.\r\n     * @param bodyType The type of body that this character creator should acknowledge.\r\n     */\r\n    handleBodySelection(bodyMap: BodyMap) {\r\n        const newImagesToRender: Array<string> = new Array<string>(0);\r\n\r\n        bodyMap.layers.forEach(layer => {\r\n            layer.images.forEach(image => {\r\n                if (image.imageSource.includes('default.png'))\r\n                {\r\n                    newImagesToRender[layer.layerIndex] = image.imageSource;\r\n                }\r\n                // image.tags.forEach(tag => {\r\n                //     if (tag === 'default') {\r\n                //         // Javascript doesn't have arrays of fixed length, so this is safe? Still getting used\r\n                //         // to this.\r\n                //         newImagesToRender[layer.layerIndex] = image.imageSource;\r\n                //     }\r\n                // });\r\n            });\r\n        });\r\n\r\n        this.setState({\r\n            canvasImages: newImagesToRender,\r\n            partLayers: bodyMap.layers\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @description\r\n     * Renders a series of body selectors for the user to pick from. These body selectors will modify the list\r\n     * of available accessories (since a tiny hat looks silly on a giant person . . . or does it?). Needs to\r\n     * look at the BodyMap.tsx file to understand what will be populated.\r\n     */\r\n    renderBodySelection() {\r\n        return bodyMaps.map((bodyMap) => {\r\n            return (\r\n                <Carousel.Item>\r\n                    <BodySelector\r\n                        onClick={(body: BodyMap) => this.handleBodySelection(body)}\r\n                        bodyMap={bodyMap}\r\n                    />\r\n                </Carousel.Item>\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @description\r\n     * Handles a carousel selection event. Is used to ensure that the carousel cycles left when the left\r\n     * button is pressed; and the same for the right button.\r\n     * @param eventKey The event key. This is the index that the carousel is being cycled to.\r\n     * @param direction The direction that the carousel is being cycled in.\r\n     */\r\n    handleCarouselSelect(eventKey: any, direction: \"prev\" | \"next\") {\r\n        this.setState({\r\n            carouselIndex: eventKey,\r\n            carouselDirection: direction\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Renders this object.\r\n     */\r\n    render() {\r\n        const canvasImagesToRender = this.state.canvasImages;\r\n        const currentBodyMap = this.state.partLayers;\r\n\r\n        return (\r\n            <div className=\"CharacterCreator\">\r\n                <h1>Character Creator</h1>\r\n                <Container fluid={true}>\r\n                    <Row>\r\n                        <Col lg={1} />\r\n                        <Col lg={4}>\r\n                            <div className='body-creation'>\r\n                                <div className='body-selector'>\r\n                                    <h2>Body Selection</h2>\r\n                                    <p className=\"italics\">(Each body type uses different accessories and will reset your character design)</p>\r\n                                    <Carousel\r\n                                        interval={null}\r\n                                        indicators={false}\r\n                                        onSelect={this.handleCarouselSelect.bind(this)}>\r\n                                        {this.renderBodySelection()}\r\n                                    </Carousel>\r\n                                    </div>\r\n                                    <div className='body-canvas'>\r\n                                        <CharacterCanvas\r\n                                            imagesToRender={canvasImagesToRender}\r\n                                            onClickDownload={(canvas: HTMLCanvasElement) => this.downloadImage(canvas)}\r\n                                        />\r\n                                </div>\r\n                            </div>\r\n                        </Col>\r\n                        <Col lg={6}>\r\n                            <div className='acc-selector'>\r\n                                <h2>Accessory Selection</h2>\r\n                                <p className=\"italics\">(You need to select a body first if this is empty)</p>\r\n                                <PartAccordion\r\n                                    layers={currentBodyMap}\r\n                                    onClick={(layerName: number, imageSource: string) => this.handlePartSelection(layerName, imageSource)}\r\n                                />\r\n                            </div>\r\n                        </Col>\r\n                        <Col lg={1} />\r\n                    </Row>\r\n                </Container>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default CharacterCreator;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport CharacterCreator from './CharacterCreator'\nimport * as serviceWorker from './serviceWorker';\nimport LandingSpace from './LandingSpace';\n\nReactDOM.render(<LandingSpace />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import './css/LandingSpace.css';\r\n\r\nimport React from 'react';\r\nimport {\r\n    BrowserRouter as Router,\r\n    Switch,\r\n    Route,\r\n    Link\r\n} from \"react-router-dom\";\r\nimport CharacterCreator from './CharacterCreator';\r\n\r\ninterface ILandingSpaceProps {\r\n};\r\n\r\ninterface ILandingSpaceState {\r\n};\r\n\r\nexport default function LandingSpace() {\r\n    return (\r\n        <div className=\"page-nav\">\r\n            <Router>\r\n                <div className=\"nav-bar\">\r\n                    <h1>Here Be Links</h1>\r\n                    <h2 className=\"nav-entry\">\r\n                        <Link to=\"/creatorPage\">\r\n                            &gt;&gt;&gt; DnD Character Creator &lt;&lt;&lt;\r\n                        </Link>\r\n                    </h2>\r\n                </div>\r\n                <Switch>\r\n                    <Route path=\"/creatorPage\" component={CharacterCreator} />\r\n                </Switch>\r\n            </Router>\r\n        </div>\r\n    )\r\n}\r\n"],"sourceRoot":""}